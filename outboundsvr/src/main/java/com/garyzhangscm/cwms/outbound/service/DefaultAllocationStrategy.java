package com.garyzhangscm.cwms.outbound.service;

import com.garyzhangscm.cwms.outbound.clients.InventoryServiceRestemplateClient;
import com.garyzhangscm.cwms.outbound.exception.AllocationException;
import com.garyzhangscm.cwms.outbound.exception.GenericException;
import com.garyzhangscm.cwms.outbound.exception.ShortAllocationException;
import com.garyzhangscm.cwms.outbound.model.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class DefaultAllocationStrategy implements AllocationStrategy {

    private static final Logger logger = LoggerFactory.getLogger(AllocationService.class);
    @Autowired
    private PickService pickService;
    @Autowired
    private InventorySummaryService inventorySummaryService;
    @Autowired
    private ShortAllocationService shortAllocationService;

    @Autowired
    private InventoryServiceRestemplateClient inventoryServiceRestemplateClient;

    @Override
    public AllocationStrategyType getType() {
        return AllocationStrategyType.FIRST_IN_FIRST_OUT;
    }

    @Override
    public AllocationResult allocate(AllocationRequest allocationRequest) {
        Item item = allocationRequest.getItem();
        Long openQuantity = allocationRequest.getQuantity();
        InventoryStatus inventoryStatus = allocationRequest.getInventoryStatus();

        logger.debug("Start to allocate request with FIFO. \n item: {} \n quantity: {} \n inventory status: {}",
                allocationRequest.getItem().getName(),
                allocationRequest.getQuantity(),
                inventoryStatus.getName());

        List<Pick> existingPicks = pickService.getOpenPicksByItemId(item.getId());

        List<Inventory> pickableInventory
                = inventoryServiceRestemplateClient.getPickableInventory(
                item.getId(), inventoryStatus.getId());

        List<InventorySummary> inventorySummaries = sort(inventorySummaryService.getInventorySummaryForAllocation(pickableInventory));


        // Let's get all the pickable inventory and existing picks to the trace file
        logger.debug("We have {} existing picks against this item", existingPicks.size());
        existingPicks.stream().forEach(pick -> {
            logger.debug("pick # {}, source location: {}, destination location: {}, quantity: {}, picked quantity: {}",
                    pick.getNumber(), pick.getSourceLocation().getName(),
                    pick.getDestinationLocation().getName(),
                    pick.getQuantity(), pick.getPickedQuantity());
        });

        logger.debug("We have inventory snapshot for allocation:");
        inventorySummaries.stream().forEach(inventorySummary -> {
            logger.debug("Inventory location: {},  quantity: {}",
                    inventorySummary.getLocation().getName(),
                    inventorySummary.getQuantity());
        });

        return allocate(allocationRequest, item, openQuantity,
                inventorySummaries, existingPicks);
    }

    /**
     * Allocate inventory. We will try those four possible ways to allocate
     * 1. Allocate by LPN(only if allowed)
     * 2. Allocate by UOM
     * 3. Allocate by LPN and round up(only if both LPN and Round up are allowed)
     * 4. Allocate by LPN and round up(only if both LPN and Round up are allowed)
     * We will provide a default implementation of each allocation method here but
     * recommend a more specific allocation strategy to override
     * @param allocationRequest  Allocation request
     * @param item Item to be allocated
     * @param totalQuantity Total quantity to be allocated
     * @param inventorySummaries Inventory candidate for allocation
     * @param existingPicks open picks from those inventory candidate
     * @return
     */
    protected AllocationResult allocate(AllocationRequest allocationRequest,
                                        Item item, Long totalQuantity,
                                         List<InventorySummary> inventorySummaries,
                                         List<Pick> existingPicks) {

        // All picks generated by this allocation will be saved in the list
        AllocationResult allocationResult = new AllocationResult();

        boolean allocationByLPN = isAllocateByLPNAllowed(item);
        AllocationRoundUpStrategy allocationRoundUpStrategy = getAllocationRoundUpStrategy(item);

        // openQuantity is the quantity that still left to be allocated
        long openQuantity = totalQuantity;

        if (allocationByLPN) {
            // try allocating by LPN, without round up first
            allocationResult.addPicks(tryAllocateByLPN(allocationRequest, openQuantity, inventorySummaries, existingPicks,
                    AllocationRoundUpStrategy.none()));
        }
        // Let's see how many we have allocated
        openQuantity = totalQuantity - getTotalPickQuantity(allocationResult);
        if(openQuantity <= 0) {
            // OK, we allocated enough quantity, let's return
            return allocationResult;
        }

        // If we are here, we know we don't have enough allocated quantity, we will try
        // allocate by UOM, without round up

        allocationResult.addPicks(tryAllocateByUnitOfMeasure(allocationRequest, openQuantity, inventorySummaries, existingPicks,
                AllocationRoundUpStrategy.none()));


        // Let's see how many we have allocated
        openQuantity = totalQuantity - getTotalPickQuantity(allocationResult);
        if(openQuantity <= 0) {
            // OK, we allocated enough quantity, let's return
            return allocationResult;
        }


        //
        // If we are still here, we know we are still short of some quantity
        // We will try round up the quantity to either full LPN quantity
        // or whole UOM quantity (only if allowed)
        //
        if (allocationRoundUpStrategy.isRoundUpAllowed()) {
            if (allocationByLPN) {
                // try allocating by LPN, without round up first
                allocationResult.addPicks(tryAllocateByLPN(allocationRequest, openQuantity, inventorySummaries, existingPicks,
                        allocationRoundUpStrategy));
            }
            // Let's see how many we have allocated
            openQuantity = totalQuantity - getTotalPickQuantity(allocationResult);
            if(openQuantity <= 0) {
                // OK, we allocated enough quantity, let's return
                return allocationResult;
            }
            // If we are here, we know we don't have enough allocated quantity, we will try
            // allocate by UOM, without round up

            allocationResult.addPicks(tryAllocateByUnitOfMeasure(allocationRequest, openQuantity, inventorySummaries, existingPicks,
                    allocationRoundUpStrategy));


            // Let's see how many we have allocated
            openQuantity = totalQuantity - getTotalPickQuantity(allocationResult);
            if(openQuantity <= 0) {
                // OK, we allocated enough quantity, let's return
                return allocationResult;
            }
        }

        // If we are still here, we are short of some quantity
        Long shortQuantity = totalQuantity - getTotalPickQuantity(allocationResult);
        if (shortQuantity > 0) {

            allocationResult.addShortAllocation(generateShortAllocation(allocationRequest, item, shortQuantity));
        }
        return allocationResult;



    }

    private long getTotalPickQuantity(AllocationResult allocationResult) {
        return allocationResult.getPicks().stream().map(Pick::getQuantity).mapToLong(Long::longValue).sum();
    }

    private List<Pick> tryAllocateByUnitOfMeasure(AllocationRequest allocationRequest, long openQuantity,
                                                  List<InventorySummary> inventorySummaries,
                                                  List<Pick> existingPicks,
                                                  AllocationRoundUpStrategy allocationRoundUpStrategy){

        List<Pick> picks = new ArrayList<>();
        long totalQuantityToBeAllocated = openQuantity;
        // Let's try to allocate by LPN
        for(InventorySummary inventorySummary : inventorySummaries) {

            if (totalQuantityToBeAllocated <=0) {
                // we got enough quantity
                // let's return;
                break;
            }

            ItemUnitOfMeasure smallestPickableUnitOfMeasure =
                    getSmallestPickableUnitOfMeasure(inventorySummary);

            if (Objects.isNull(smallestPickableUnitOfMeasure)) {
                logger.debug("No pickable unit of measure defined for the inventory summary, {} / {}",
                        inventorySummary.getItem().getName(), inventorySummary.getItemPackageType().getName());
                continue;
            }


            logger.debug("Will try to allocate with smallestPickableUnitOfMeasureQuantity: {}",
                    smallestPickableUnitOfMeasure.getQuantity());

            // Get the quantity that already allocated to certain pick
            // we will need to make sure even after we allocate from certain LPN,
            // we will still have enough quantity for the existing picks
            // to verify the quantity, we will skip the quantity that 'allocated by LPN' type
            // of picks
            List<Pick> existingPicksByInventorySummary = getExistingPicksByInventorySummary(inventorySummary, existingPicks);

            // pickByQuantityPicksTotalOpenQuantity will return all open quantity that allocated
            // by NON LPN picks
            // getAvailableInventoryQuantity will return all available quantity that excludes
            // the LPN that has been allocated by LPN picks.
            // the balance of those 2 number is the available quantity that can be allocated at this moment
            long pickByQuantityPicksTotalOpenQuantity = pickByQuantityPicksTotalOpenQuantity(existingPicksByInventorySummary);
            long availableInventoryQuantity = getAvailableInventoryQuantity(inventorySummary);

            long allocatibleQuantity = getAllocatiableQuantityByUnitOfMeasure(
                    (availableInventoryQuantity - pickByQuantityPicksTotalOpenQuantity),
                    smallestPickableUnitOfMeasure.getQuantity(),
                    totalQuantityToBeAllocated,
                    allocationRoundUpStrategy
                    );

            logger.debug("We can allocate {} from location {}, item {}", allocatibleQuantity,
                    inventorySummary.getLocation().getName(), inventorySummary.getItem().getName());

            if (allocatibleQuantity ==0) {
                // we can't allocate anything from this location
                continue;
            }

            try {
                Pick pick = tryCreatePickForUOMAllocation(allocationRequest, inventorySummary, allocatibleQuantity, smallestPickableUnitOfMeasure);
                picks.add(pick);
                totalQuantityToBeAllocated -= allocatibleQuantity;


            }
            catch (GenericException ex) {
                // in case we can't generate the pick from this location, let's
                // continue and try next location
                continue;
            }







        }
        return picks;
    }

    private Pick tryCreatePickForUOMAllocation(AllocationRequest allocationRequest, InventorySummary inventorySummary,
                                               long allocatibleQuantity, ItemUnitOfMeasure smallestPickableUnitOfMeasure) {
        if (allocationRequest.getShipmentLines().size() > 0) {
            return pickService.generatePick(inventorySummary, allocationRequest.getShipmentLines().get(0),
                    allocatibleQuantity, smallestPickableUnitOfMeasure);
        }
        else {
            throw AllocationException.raiseException("now we only support new allocation for single shipment line");
        }

    }

    /**
     * Check how many quantity we can allocate from the location
     * @param avaiableQuantity total available quantity in the location
     * @param pickableUnitOfMeasureQuantity pickable UOM quantity. We can only pick by multiple of this quantity
     * @param quantityToBeAllocated total quantity we need
     * @param allocationRoundUpStrategy round up strategy
     * @return quantity can be allocated from this location
     */
    private long getAllocatiableQuantityByUnitOfMeasure(long avaiableQuantity,
                                                        long pickableUnitOfMeasureQuantity,
                                                        long quantityToBeAllocated,
                                                        AllocationRoundUpStrategy allocationRoundUpStrategy) {

        logger.debug("getAllocatiableQuantityByUnitOfMeasure: \n " +
                "avaiableQuantity: {}\n" +
                "pickableUnitOfMeasureQuantity: {}\n" +
                "quantityToBeAllocated: {}\n" +
                "allocationRoundUpStrategy: {}",
                avaiableQuantity,
                pickableUnitOfMeasureQuantity,
                quantityToBeAllocated,
                allocationRoundUpStrategy);
        if (pickableUnitOfMeasureQuantity > avaiableQuantity) {
            // we can't even pick a uint of measure from this location,

            logger.debug("we don't have enough quantity in the location, even for one unit of measure " +
                    "pickableUnitOfMeasureQuantity: {}, avaiableQuantity: {}",
                    pickableUnitOfMeasureQuantity, avaiableQuantity);
            return 0;
        }

        // we are only allowed to pick by unit of measure
        long avaiableQuantityInUnitOfMeasure = avaiableQuantity / pickableUnitOfMeasureQuantity;

        logger.debug("avaiableQuantityInUnitOfMeasure: {}",
                avaiableQuantityInUnitOfMeasure);

        // if we have quantity less than required, then allocate them all
        if (avaiableQuantityInUnitOfMeasure * pickableUnitOfMeasureQuantity <= quantityToBeAllocated) {

            logger.debug("we don't have enough quantity in the location. return what ever we have: " +
                            "avaiableQuantityInUnitOfMeasure * pickableUnitOfMeasureQuantity: {}",
                    avaiableQuantityInUnitOfMeasure * pickableUnitOfMeasureQuantity);

            return avaiableQuantityInUnitOfMeasure * pickableUnitOfMeasureQuantity;
        }
        else {

            logger.debug("We have enough quantity in the location, let's try some more strategy");
            // we have more than required, we will still need to allocate by unit of measure
            // 1. if quantityToBeAllocated can be divided evenly by UOM quantity, then we allocate
            //    just the required quantity
            // 2. if quantityToBeAllocated can not be divided evenly by UOM quantity, and round up is not
            //    allowed, then we will allocate as mush as possible but not exceed the requirement amount
            // 3. if quantityToBeAllocated  can not be divided evenly by UOM quantity, and round up is  allowed,
            //    then we may allocate more than needed, but as less over allocation as possible
            long unitOfMeasureQuantityToBeAllocated = quantityToBeAllocated / pickableUnitOfMeasureQuantity;

            logger.debug("Let's see if we can allocate {} unit of measure from this location: " ,
                    unitOfMeasureQuantityToBeAllocated);

            if (quantityToBeAllocated % pickableUnitOfMeasureQuantity == 0) {

                logger.debug("we can allocate {} unit of measure from this location, as it can be divided by the UOM quantity: {}" ,
                        unitOfMeasureQuantityToBeAllocated, pickableUnitOfMeasureQuantity);
                return quantityToBeAllocated;
            }
            else if (!allocationRoundUpStrategy.isRoundUpAllowed()){
                // round up is not allowed and required quantity can't be divided evenly
                // by uom quantity, then allocate by unit of measure quantity, which may be
                // a bit less than needed
                logger.debug("quantityToBeAllocated % pickableUnitOfMeasureQuantity is not 0, and round up is not allowed, will return {}" ,
                        unitOfMeasureQuantityToBeAllocated * pickableUnitOfMeasureQuantity);
                return unitOfMeasureQuantityToBeAllocated * pickableUnitOfMeasureQuantity;
            }
            else{
                long maxQuantityToBeAllocated = 0;
                switch (allocationRoundUpStrategy.getType()) {
                    case BY_QUANTITY:
                        maxQuantityToBeAllocated  = quantityToBeAllocated + (long)allocationRoundUpStrategy.getValue().doubleValue();
                        break;
                    case BY_PERCENTAGE:
                        maxQuantityToBeAllocated  = (long)(quantityToBeAllocated * (100 + allocationRoundUpStrategy.getValue()) / 100);
                        break;
                    case NO_LIMIT:
                        maxQuantityToBeAllocated = Long.MAX_VALUE;
                        break;
                    default:
                        maxQuantityToBeAllocated = quantityToBeAllocated;
                        break;
                }
                // convert the max quantity to max unit of measure quantity
                long maxUnitOfMeasureQuantityToBeAllocated = maxQuantityToBeAllocated / pickableUnitOfMeasureQuantity;
                logger.debug("quantityToBeAllocated % pickableUnitOfMeasureQuantity is not 0, and round up is allowed, \n" +
                        "max quantity allowed is {}, max quantity of UOM is {}, uom quantity required is {}" ,
                        maxQuantityToBeAllocated, maxUnitOfMeasureQuantityToBeAllocated, unitOfMeasureQuantityToBeAllocated);
                // if the max unit of measure quantity is bigger than the required quantity, then round up
                if (maxUnitOfMeasureQuantityToBeAllocated > unitOfMeasureQuantityToBeAllocated) {
                    logger.debug("Will round up by one UOM, final quantity is {}",
                            (unitOfMeasureQuantityToBeAllocated + 1) * pickableUnitOfMeasureQuantity);
                    return (unitOfMeasureQuantityToBeAllocated + 1) * pickableUnitOfMeasureQuantity;
                }
                else {
                    // OK, even we allow round up, the result is still the same as no round up, due to the
                    // restriction of the unit of measure quantity
                    logger.debug("Will NOT round up by one UOM, final quantity is {}",
                            unitOfMeasureQuantityToBeAllocated * pickableUnitOfMeasureQuantity);
                    return unitOfMeasureQuantityToBeAllocated * pickableUnitOfMeasureQuantity;
                }

            }
        }
    }

    private List<Pick> tryAllocateByLPN(AllocationRequest allocationRequest, Long openQuantity,
                                  List<InventorySummary> inventorySummaries,
                                  List<Pick> existingPicks, AllocationRoundUpStrategy allocationRoundUpStrategy) {
        List<Pick> picks = new ArrayList<>();
        long totalQuantityToBeAllocated = openQuantity;
        // Let's try to allocate by unit of measure

        for(InventorySummary inventorySummary : inventorySummaries) {
            if (totalQuantityToBeAllocated <=0) {
                // we got enough quantity
                // let's return;
                break;
            }
            // skip the inventory if it is already 'allocated by LPN'
            // inventory map in the inventory summary:
            // key: lpn
            // value: list of the inventory on the lpn
            Map<String, List<Inventory>> lpnInventories = inventorySummary.getInventories();
            // Get the quantity that already allocated to certain pick
            // we will need to make sure even after we allocate from certain LPN,
            // we will still have enough quantity for the existing picks
            // to verify the quantity, we will skip the quantity that 'allocated by LPN' type
            // of picks
            List<Pick> existingPicksByInventorySummary = getExistingPicksByInventorySummary(inventorySummary, existingPicks);


            // setup the LPN and quantity that can be allocated;
            // AN lpn either can be allocated as full, or
            // can't be allocated at all
            Map<String, Long> lpnQuantityToBeAllocatedMap = new HashMap<>();

            // Go through each LPN to see if we can allocate from the whole LPN
            Iterator<Map.Entry<String, List<Inventory>>> lpnInventoryIterator = lpnInventories.entrySet().iterator();
            while(lpnInventoryIterator.hasNext()) {
                Map.Entry<String, List<Inventory>> lpnInventoryMapEntry =
                        lpnInventoryIterator.next();
                // The LPN is allocatable when there's none in the
                // inventory with this LPN is allocated by certain pick
                // and we don't break the existing picks which is picked
                // by SUOM.


                if (validateLPNAllocatable(totalQuantityToBeAllocated,
                        lpnInventoryMapEntry.getValue(),
                        inventorySummary, existingPicksByInventorySummary, allocationRoundUpStrategy)) {

                    Long totalLPNquantity =
                            lpnInventoryMapEntry.getValue().stream()
                                    .mapToLong(Inventory::getQuantity).sum();
                    lpnQuantityToBeAllocatedMap.put(
                            lpnInventoryMapEntry.getKey(),
                            totalLPNquantity
                    );
                }

            }

            Iterator<Map.Entry<String, Long>> lpnToBeAllocatedMapIterator = lpnQuantityToBeAllocatedMap.entrySet().iterator();
            while(lpnToBeAllocatedMapIterator.hasNext()) {
                Map.Entry<String, Long> lpnToBeAllocated = lpnToBeAllocatedMapIterator.next();
                String lpn = lpnToBeAllocated.getKey();
                Long lpnQuantityToBeAllocated = lpnToBeAllocated.getValue();
                // allocate quantity from this LPN
                totalQuantityToBeAllocated = totalQuantityToBeAllocated - lpnQuantityToBeAllocated;
                // create the pick
                Pick pick = tryCreatePickForLPNAllocation(lpn, lpnQuantityToBeAllocated, inventorySummary);
                picks.add(pick);
                // setup the pick on the inventory of this LPN
                lpnInventories.get(lpn).forEach(inventory -> inventory.setAllocatedByPick(pick));

            }
        }
        return picks;
    }

    private Pick tryCreatePickForLPNAllocation(String lpn, Long lpnQuantityToBeAllocated, InventorySummary inventorySummary) {
        return null;
    }

    /**
     * Check if we can allocate from this LPN, by 'allocate by LPN'
     * @param lpnInventories inventories on this LPN
     * @param inventorySummary inventories summary in the location
     * @param existingPicksByInventorySummary existing picks in the location
     * @return
     */
    private boolean validateLPNAllocatable(long totalQuantityToBeAllocated,
                                           List<Inventory> lpnInventories,
                                           InventorySummary inventorySummary,
                                           List<Pick> existingPicksByInventorySummary,
                                           AllocationRoundUpStrategy allocationRoundUpStrategy) {

        boolean lpnAlreadyAllocated =
                lpnInventories.stream()
                        .anyMatch(inventory -> Objects.nonNull(inventory.getAllocatedByPickId()));
        // if the LPN is allocated by certain pick, then it is not valid for new pick
        if (lpnAlreadyAllocated) {
            return false;
        }
        Long quantityByLPN = lpnInventories.stream().mapToLong(Inventory::getQuantity).sum();
        long maxQuantityToBeAllocated = totalQuantityToBeAllocated;
        // make sure
        // 1. if round up is not allowed, then the LPN's quantity doesn't exceed the quantity needed
        // 2. if round up is allowed, then the LPN's quantity doesn't exceed the max round up quantity
        switch (allocationRoundUpStrategy.getType()) {
            case BY_PERCENTAGE:
                maxQuantityToBeAllocated = (long)(totalQuantityToBeAllocated * (100 + allocationRoundUpStrategy.getValue()) / 100);
                break;
            case NO_LIMIT:
                // when there's no limit, we can allocate the whole LPN quantity
                maxQuantityToBeAllocated = quantityByLPN;
                break;
            case BY_QUANTITY:
                maxQuantityToBeAllocated = totalQuantityToBeAllocated + (long)allocationRoundUpStrategy.getValue().doubleValue();
                break;
            default:
                // by default, we won't allow over allocation
                maxQuantityToBeAllocated = totalQuantityToBeAllocated;
                break;
        }
        if (maxQuantityToBeAllocated < quantityByLPN) {
            // the max quantity we are allowed to allocate is less than the whole LPN's quantity,
            // which means we can't allocate from this LPN
            return false;
        }

        return validateQuantityAllocatable(quantityByLPN, inventorySummary, existingPicksByInventorySummary);
    }

    /**
     * check if we can allocate the quantity from the inventory summary.
     *
     * we will ignore that LPN that is already allocated to certain picks and those
     * picks as well. Then we only have those picks that is allocated by quantity
     * and the inventory that is not allocated by LPN yet., both of which are quantity
     * based.
     * @param quantityToBeAllocated
     * @param inventorySummary
     * @param existingPicksByInventorySummary
     * @return
     */
    private boolean validateQuantityAllocatable(Long quantityToBeAllocated,
                                                InventorySummary inventorySummary,
                                                List<Pick> existingPicksByInventorySummary) {

        // the LPN is not allocated by certain pick, let's see if we can allocate the quantity
        // from this LPN, while not breaking other open picks
        // we will only validate against the picks that allocate by quantity
        Long pickByQuantityPicksTotalOpenQuantity = pickByQuantityPicksTotalOpenQuantity(existingPicksByInventorySummary);
        Long availableInventoryQuantity = getAvailableInventoryQuantity(inventorySummary);

        if (quantityToBeAllocated + pickByQuantityPicksTotalOpenQuantity <= availableInventoryQuantity) {
            return true;
        }
        else {
            return false;
        }
    }

    /**
     * Get the total open quantity of picks from a inventory, excluding those picked by LPN
     * @param existingPicks
     * @return
     */
    private long pickByQuantityPicksTotalOpenQuantity(List<Pick> existingPicks) {
        return existingPicks.stream()
                .filter(pick -> Objects.isNull(pick.getLpn()))
                .map(pick -> pick.getQuantity()-pick.getPickedQuantity())
                .mapToLong(Long::longValue).sum();
    }

    /**
     * get available inventory quantity, exclued those lPN that already allocated.
     * Note: the quantity will include the quantity that already allocated by picks
     * that is not Allocate By LPN
     * @param inventorySummary
     * @return
     */
    private long getAvailableInventoryQuantity(InventorySummary inventorySummary) {
        return inventorySummary.getInventories().entrySet().stream()
                .filter(entry -> {
                    List<Inventory> inventories = entry.getValue();
                    if(inventories.stream().anyMatch(inventory -> Objects.nonNull(inventory.getAllocatedByPickId()))) {
                        // the LPN is allocated, let's ignore this as it is not valid
                        return false;
                    }
                    return true;
                }).mapToLong(entry -> {
                    // return the total quantity of this LPN
                    List<Inventory> inventories = entry.getValue();
                    return inventories.stream().map(Inventory::getQuantity).mapToLong(Long::longValue).sum();
                }).sum();
    }

    /**
     * Get the picks from a specific location out of all existing picks against the item
     * @param inventorySummary inventory summary of certain item in certain location
     * @param existingPicks existing picks against certain item
     * @return
     */
    private List<Pick> getExistingPicksByInventorySummary (InventorySummary inventorySummary, List<Pick> existingPicks) {

        return existingPicks.stream()
                .filter(pick -> pick.getSourceLocationId().equals(inventorySummary.getLocationId()))
                .collect(Collectors.toList());
    }
    /**
     * Return the smallest unit of measure of the inventory
     * By default we assume all the unit of measure is pickable in the location and will return
     * the one with smallest quantity. This is supposed to be override by child implementation
     * @param inventorySummary
     * @return
     */
    protected ItemUnitOfMeasure getSmallestPickableUnitOfMeasure(InventorySummary inventorySummary) {
        // By default, we return the smallest unit of measure of the inventory in the summary
        return inventorySummary.getInventories().entrySet().stream().map(entry -> entry.getValue())
                .flatMap(List::stream).map(inventory -> inventory.getItemPackageType().getItemUnitOfMeasures())
                .flatMap(List::stream)
                .min((unitOfMeasure1, unitOfMeasure2) -> (int) (unitOfMeasure1.getQuantity() - unitOfMeasure2.getQuantity()))
                .orElse(null);
    }


    protected AllocationRoundUpStrategy getAllocationRoundUpStrategy(Item item) {
        return AllocationRoundUpStrategy.unlimit();
    }
    protected boolean isAllocateByLPNAllowed(Item item) {
        return true;
    }
    /**
     * Sort the inventory summaries based upon certain rules. The child class with
     * different stategy is supposed to override this method so it can implement
     * different rules to sort the inventory summary and get a different allocation result
     * @param inventorySummaries inventory summary list to be sorted
     * @return inventory summary list after being sorted
     */
    protected List<InventorySummary> sort(List<InventorySummary> inventorySummaries) {

        // by default, we do nothing
        return inventorySummaries;

    }

    private ShortAllocation generateShortAllocation(Item item, ShipmentLine shipmentLine, Long quantity) {

        return shortAllocationService.generateShortAllocation(item, shipmentLine, quantity);

    }

    private ShortAllocation generateShortAllocation(WorkOrder workOrder, Item item, WorkOrderLine workOrderLine, Long quantity) {

        return shortAllocationService.generateShortAllocation(workOrder, item, workOrderLine, quantity);

    }
    /**
     * @param allocationRequest
     * @param item
     * @param quantity
     * @return
     */
    private ShortAllocation generateShortAllocation(AllocationRequest allocationRequest, Item item, Long quantity) {

        // For now we will only support allocate one line by one line
        // either shipment line or work order line
        if (allocationRequest.getShipmentLines().size() > 0) {
            return generateShortAllocation(item, allocationRequest.getShipmentLines().get(0), quantity);
        }

        else if (allocationRequest.getWorkOrderLines().size() > 0) {
            // TO-DO
            // allocation for work order
        //    WorkOrderLine workOrderLine = allocationRequest.getWorkOrderLines().get(0);

        //    return generateShortAllocation(item, allocationRequest.getWorkOrderLines().get(0), quantity);
            return null;

        }
        else {
            throw ShortAllocationException.raiseException("Can't generate short allocation for allocation request: ");
        }

    }


}
